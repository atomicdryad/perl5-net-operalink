#!/usr/bin/env perl
#
# Get your Opera Link speeddials and bookmarks
#
# Usage:
#   ./link-api-example

use strict;
use warnings;

use Data::Dumper;
use Net::OperaLink ();
use File::Slurp ();

# Test keys. Get your own at:
#   https://auth.opera.com/service/oauth/applications/

our $CONSUMER_KEY    = 'test_desktop_key';
our $CONSUMER_SECRET = 'p2FlOFGr3XFm5gOwEKKDcg3CvA4pp0BC';

if ( -e "$ENV{HOME}/.operaapi" ) { # lazy coder: record the values of the $CONSUMER vars as so: 'key=blahblahblah secret=omgwtfbbq'
  open API,"<$ENV{HOME}/.operaapi";
  ($CONSUMER_KEY,$CONSUMER_SECRET) = join('',<API>) =~ m,key=([a-z0-9]+).*?secret=([a-z0-9]+),simg or die "invalid ~/.operaapi";
  close API;
}

my $rc_file = exists $ENV{HOME}
    ? "$ENV{HOME}/.operalinkrc"
    : ".operalinkrc" ;

# Read tokens from the .rc file
sub restore_tokens {
    my @tokens;

    if (-s $rc_file) {
        @tokens = File::Slurp::read_file($rc_file);
        chomp @tokens;
        if (
            (@tokens != 2) ||
            ($tokens[0] !~ m{^ [\w\-]+ $}x) ||
            ($tokens[1] !~ m{^ [\w\-]+ $}x)
        ) {
            die "Invalid tokens in $rc_file. Maybe delete '$rc_file?'\n";
        }
    }

    return @tokens;
}


# Save tokens to the .rc file
sub save_tokens {
    my (@tokens) = @_;

    open(my $rc_fh, ">$rc_file")
        or die "Can't open $rc_file: $!";
    print $rc_fh $tokens[0], "\n", $tokens[1], "\n";
    close $rc_fh;
}

my $link = Net::OperaLink->new(
    consumer_key    => $CONSUMER_KEY,
    consumer_secret => $CONSUMER_SECRET,
    croak => 0, # I have no idea why perloo modules are always coded to be deathtraps. If you like the previous behavior, set to 1
    debug => 1, # 1 prints get urls, etc, 2 dumps lwp response 
);

# You'll save the token and secret in cookie, config file or session database
my ($access_token, $access_token_secret) = restore_tokens();
if ($access_token && $access_token_secret) {
    $link->access_token($access_token);
    $link->access_token_secret($access_token_secret);
}

unless ($link->authorized) {
    # The client is not yet authorized: Do it now
    print "Please authorize me at ", $link->get_authorization_url, " and then\n",
        "type the verifier + ENTER to continue\n";
    chomp (my $verifier = <STDIN>);
    my($access_token, $access_token_secret) = $link->request_access_token(verifier => $verifier);
    save_tokens($access_token, $access_token_secret);
}

sub arr { 
  return (ref($_[0]) eq 'ARRAY'? @{$_[0]} : undef);
}

sub hash {
  return (ref($_[0]) eq 'HASH'? %{$_[0]} : undef);
}



sub bm_print_recursive {
  my %ent=hash(shift) or return;
  my $indent=shift || 0;
  die "bookmark depth of 256 reached, aborting for safety reasons." if ($indent>=256);
  print "" . ("\t" x $indent ) . $ent{properties}{title} . ($ent{item_type} eq 'bookmark_folder'?'/':"\t$ent{properties}{uri}") . "\n";
  if ($ent{item_type} eq 'bookmark_folder') {
    if ( my $res = $link->bookmark("$ent{id}",'children' ) ) {
      bm_print_recursive($_,$indent+1) foreach(arr($res));   
    }
  }
}


$link->debug(2);

my $res;

if ($res = $link->speeddial(1)) {
  print Dumper($res)."\n";
} else {
  print "Error: link->speeddial(1) - ".$link->error()."\n";
}

my $testid="EB1B8E39EF1949E6BC6987A3769172F9";

if ( $res = $link->bookmark($testid,'descendants') ) {
  print Dumper($res);
} else {
  print "Error: link->bookmark($testid) - ".$link->error()."\n";
}
exit;

$link->debug(0);
if ( $res = $link->bookmarks() ) {
  bm_print_recursive($_) foreach(arr($res));
} else {
  print "Error: link->bookmarks() - ".$link->error()."\n";
}


